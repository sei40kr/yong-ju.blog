---
title: "コンピュータアーキテクチャ"
categories: ["低レイヤ"]
tags: ["コンピュータアーキテクチャ", "低レイヤ", "プロセッサ", "メモリ管理", "勉強ノート"]
date: 2022-05-15T08:44:29+09:00
---

## マイクロアーキテクチャ

### スーパースカラ

**スーパースカラ (superscalar)** は、クロックサイクル毎に複数の命令を読みそれらを複数のユニットを使って処理することで1サイクル当たりの並列実行命令数を増やす、プロセッサの最適化手法の一つである。

### パイプライン処理

プロセッサの命令は以下のステージに細分化することができる。 (ただし、プロセッサはRISCを採用しているとする)

| 内部処理                 | 略称                    | 内容                                                                  | 利用する機能ユニット  |
|:-------------------------|:------------------------|:----------------------------------------------------------------------|:----------------------|
| 命令フェッチ             | IF (Instruction Fetch)  | メモリあるいは命令キャッシュから命令を読む                            | フェッチユニット      |
| 命令デコード             | ID (Instruction Decode) | 命令を解釈する                                                        | デコードユニット      |
| オペランド               | RR (Register Read)      | 命令の実行に必要なオペランド (operand, 演算の対象) をレジスタから読む | レジスタファイル      |
| メモリアクセス           | MA (Memory Access)      | メモリを読み書きする                                                  | ロード/ストアユニット |
| 実行                     | EX (EXecute)            | 指定された演算を行う                                                  | 演算ユニット          |
| レジスタへのライトバック | WB (Write Back)         | 演算結果をレジスタに書く                                              | レジスタファイル      |

処理中の命令の終了を待って次の命令の処理を開始するのでは、機能ユニットが遊んでいるサイクルが発生してしまう。
そこで、それぞれの機能ユニットの処理結果をレジスタに格納し次のサイクルには次の命令の処理を始めることで、順次実行するより性能向上が期待できる。
この方式を**パイプライン (pipeline) 処理**方式という。

**命令パイプラインのイメージ**

| クロックサイクル/命令No | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  |
|:------------------------|:---|:---|:---|:---|:---|:---|:---|:---|
| 1                       | IF | ID | RR | EX | MA | WB |    |    |
| 2                       |    | IF | ID | RR | EX | MA | WB |    |
| 3                       |    |    | IF | ID | RR | EX | MA | WB |
| 4                       |    |    |    | IF | ID | RR | EX | MA |

### パイプラインハザード

プログラマがプログラムを書くとき、命令は書かれた順序通りに逐次実行されることを期待する。
前述のパイプライン処理を行う場合と逐次実行した場合で結果が異なる場合、それを回避するために命令パイプラインへの命令の投入を中断せざるを得ない状況が生じうる。
これを**パイプラインハザード (pipeline hazard)** という。
パイプラインハザードには以下の3つに分類される。

構造ハザード
: 他の命令とのハードウェア資源の競合が発生し、一方の命令がもう一方を待つことによるハザード。

データハザード
: ある命令のオペランドがその前の命令の演算結果である場合、前の命令の処理完了を待つことによるハザード。

制御ハザード
: 分岐条件の成立/不成立で処理を分岐する場合、条件が評価されるまで分岐先の命令をフェッチできないことによるハザード。

また、命令パイプライン中の命令を実行できないステージを**パイプラインバブル (pipeline bubble)** という。

### レジスタバイパス

**レジスタバイパス (register bypass)** はある命令のオペランドがその前の命令の演算結果である場合に前の命令の演算結果をレジスタを経由せずに直接受け取ることにより、演算結果をレジスタに書くステージ (WB) とオペランドをレジスタから読むステージ (RR) を省略する、プロセッサの最適化手法の一つである。
これにより、前述の**データハザードの軽減**が期待できる。

### 分岐予測

**分岐予測 (branch prediction)** は、プログラム実行の中で条件分岐命令が分岐するかしないかを予測する、プロセッサの最適化手法の一つである。

Out-of-Order実行と組み合わせて、予測に基づき条件分岐命令後の命令を先に実行してしまう方式を**投機実行 (speculative execution)** といい、これにより前述の**制御ハザードの軽減**が期待できる。

#### 常に分岐が成立すると予測

例えば、`for` 文や `while` 文などのループの継続条件による条件分岐は最後のループを除いてすべて成立する。
このような理由から、常に分岐が成立すると予測したとしてもある程度の予測精度が期待できる。

#### 飽和カウンタを用いる予測

飽和カウンタを用いた予測では、それぞれの条件分岐命令ごとに過去に分岐が成立したか (taken/not taken) の履歴を2ビットのカウンタ (**飽和カウンタ**) で記憶する。

| 飽和カウンタの値 | 定義               |
|:-----------------|:-------------------|
| `00`             | Strongly Not Taken |
| `01`             | Weakly Not Taken   |
| `10`             | Weakly Taken       |
| `11`             | Strongly Taken     |

{{< hint info >}}
**参考**

- [分岐予測の簡単な歴史 – Part 1](https://postd.cc/branch-prediction-2/)
- [分岐予測の簡単な歴史 – Part 2](https://postd.cc/branch-prediction-3/)
- [分岐予測の簡単な歴史 – Part 3](https://postd.cc/branch-prediction/)
{{< /hint >}}

<!-- TODO 履歴を用いる予測 -->

### Out-of-Order実行

**Out-of-Order実行**は、プログラムにおける命令の実行順序に依らず、処理可能な (オペランドが揃っている) 命令から逐次実行することでプログラムの並列性を向上させる、プロセッサの最適化手法の一つである。

#### リザベーションステーション

Out-of-Order実行では、命令の実行順序を変更しても逐次実行したときと同じ結果が得られることを保証するため、**リザベーションステーション (reservation station)** という機構で命令を管理する。
デコードされた命令を直接実行パイプラインには送らず、命令種別ごとに設けられたリザベーションステーションに格納する。

リザベーションステーションは命令の依存関係の管理を行う。
具体的には、オペランドが揃って実行可能になった命令を順次実行パイプラインに送る。
また、リザベーションステーションは実行パイプラインの実行結果をモニタリングし、その実行結果を待つ命令があれば、実行結果をその命令のオペランドとして格納する。

<!-- TODO 逆依存とレジスタリネーム -->

<!-- TODO メモリバリア命令 -->

## マルチプロセッサシステム

### キャッシュコヒーレンシ制御

それぞれ独立したキャッシュをもつマルチプロセッサシステムにおいて、各プロセッサ間のキャッシュの整合性をとることを**キャッシュコヒーレンシ制御**という。

#### MSIプロトコル

**MSIプロトコル**は、キャッシュコヒーレンシ制御において最も基本的なプロトコルであり、キャッシュラインの状態を2つのフラグ (`Invalid`, `Modified`) で管理する。

| Invalid | Modified | 状態       |
|---------|----------|------------|
| `0`     | `0`      | Shared     |
| `0`     | `1`      | Modified   |
| `1`     | `0`      | Invalid    |
| `1`     | `1`      | 存在しない |

{{< mermaid >}}
stateDiagram-v2
  Invalid --> Shared: メモリから読み込み
  Shared --> Invalid: インバリデート要求を処理
  Shared --> Modified: キャッシュへの書き込み
  Modified --> Shared: メモリへの書き戻し要求を処理
{{< /mermaid >}}

{{< hint info >}}
MSIはキャッシュラインがとりうる3つの状態 **M**odified, **S**hared, **I**nvalid の頭文字である。
{{< /hint >}}

MSIプロトコルでは、各プロセッサはメモリの内容を書き換える前に他のプロセッサに対して同じメモリアドレスのキャッシュをインバリデートするよう要求を送る。この要求を**Snoop** (英語で「覗き」という意味) とも呼ぶ。

また、キャッシュがライトバックキャッシュである場合は、メモリからデータを読む前に、他のプロセッサに対して同じメモリアドレスのキャッシュをメモリに書き戻すよう要求を送る。
